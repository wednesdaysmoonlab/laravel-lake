#!/usr/bin/env bash
set -euo pipefail

_lake_logo() {
  local sky=$'\e[38;5;117m' db=$'\e[38;5;27m' ls=$'\e[38;5;153m' r=$'\e[0m'
  local line out i char
  while IFS= read -r line; do
    out=""
    for (( i=0; i<${#line}; i++ )); do
      char="${line:$i:1}"
      case "$char" in
        _)  out+="${ls}_" ;;
        /)  out+="${sky}/" ;;
        \\) out+="${sky}\\" ;;
        *)  out+="${r}${char}" ;;
      esac
    done
    printf '%s%s\n' "$out" "$r"
  done << 'LOGO'
     _/\/\____________________/\/\___________________
    _/\/\________/\/\/\______/\/\__/\/\____/\/\/\___
   _/\/\____________/\/\____/\/\/\/\____/\/\/\/\/\_
  _/\/\________/\/\/\/\____/\/\/\/\____/\/\_______
 _/\/\/\/\/\__/\/\/\/\/\__/\/\__/\/\____/\/\/\/\_
________________________________________________
LOGO
}
_lake_logo
unset -f _lake_logo

_say() { printf '\e[38;5;117m✦\e[0m %s\n' "$*"; }
_confirm() {
  local _ans
  printf '\e[1;31m❓ %s [Y/n]:\e[0m ' "$*" >&2
  read -r _ans </dev/tty
  _ans="${_ans:-Y}"
  [[ "$_ans" =~ ^[Yy]$ ]]
}
_ask() {  # _ask "Question [default]:" "default_value"
  local _ans
  printf '\e[1;31m❓ %s\e[0m ' "$1" >&2
  read -r _ans </dev/tty
  echo "${_ans:-${2:-}}"
}

# ======================================
#  lake.setup
#  Laravel + FrankenPHP bootstrap
#  No Docker. No local PHP required.
# ======================================

LAKE_SETUP_VERSION="0.1.0"

# ----------------------------
# --help FLAG
# ----------------------------

if [[ "${1:-}" == "help" || "${1:-}" == "--help" || "${1:-}" == "-h" ]]; then
  cat <<HELPEOF
lake.setup v${LAKE_SETUP_VERSION}

Usage:
  ./lake.setup [COMMAND]

Commands:
  purge         Remove everything in this directory except lake.setup, .claude, .git, .gitignore, CLAUDE.md, and README.md
  clean         Remove Laravel app files only; keep .lake/ (FrankenPHP, Composer, installer)
  help          Show this help message

Environment overrides:
  FRANKEN_VERSION=1.11.2   Pin a specific FrankenPHP version (default: latest)
  LAKE_PORT=9000            Skip the port prompt and use this port

Example:
  FRANKEN_VERSION=1.11.2 LAKE_PORT=9000 ./lake.setup
HELPEOF
  exit 0
fi

# ----------------------------
# purge COMMAND
# ----------------------------

if [[ "${1:-}" == "purge" ]]; then
  if [[ -n "${BASH_SOURCE[0]:-}" && -f "${BASH_SOURCE[0]}" ]]; then
    SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
    SCRIPT_NAME="$(basename "${BASH_SOURCE[0]}")"
  else
    SCRIPT_DIR="$(pwd)"
    SCRIPT_NAME=""
  fi
  _say "Purging $SCRIPT_DIR (keeping $SCRIPT_NAME)..."
  find "$SCRIPT_DIR" -mindepth 1 -maxdepth 1 \
    ! -name "$SCRIPT_NAME" \
    ! -name ".claude" \
    ! -name ".git" \
    ! -name ".gitignore" \
    ! -name "CLAUDE.md" \
    ! -name "README.md" \
    -exec rm -rf {} +
  _say "Done."
  exit 0
fi

# ----------------------------
# clean COMMAND
# ----------------------------

if [[ "${1:-}" == "clean" ]]; then
  if [[ -n "${BASH_SOURCE[0]:-}" && -f "${BASH_SOURCE[0]}" ]]; then
    SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
    SCRIPT_NAME="$(basename "${BASH_SOURCE[0]}")"
  else
    SCRIPT_DIR="$(pwd)"
    SCRIPT_NAME=""
  fi
  _say "Cleaning Laravel app files (keeping .lake/, $SCRIPT_NAME)..."
  find "$SCRIPT_DIR" -mindepth 1 -maxdepth 1 \
    ! -name "$SCRIPT_NAME" \
    ! -name ".claude" \
    ! -name ".git" \
    ! -name ".gitignore" \
    ! -name "CLAUDE.md" \
    ! -name "README.md" \
    ! -name ".lake" \
    -exec rm -rf {} +
  _say "Done. Run ./lake.setup to reinstall Laravel."
  exit 0
fi

# ----------------------------
# PREFLIGHT CHECKS
# ----------------------------

_box_row() {
  # ✅ and ❌ are 1 bash codepoint but render as 2 visual columns.
  # Compute the padding spaces explicitly to keep the right border aligned.
  local text="$1" dw=0
  [[ "$text" == *"✅"* ]] && dw=1
  [[ "$text" == *"❌"* ]] && dw=1
  local spaces=$(( 49 - ${#text} - dw ))
  printf "│%s%${spaces}s│\n" "$text" ""
}

_ok=true

# curl — required for downloading FrankenPHP and Composer
if command -v curl &>/dev/null; then
  _curl_row="  ✅ curl            required"
else
  _curl_row="  ❌ curl            required — please install"
  _ok=false
fi

# node + npm — required for Vite (dev server only)
if command -v node &>/dev/null && command -v npm &>/dev/null; then
  _node_row="  ✅ node, npm       for dev server"
elif ! command -v node &>/dev/null && ! command -v npm &>/dev/null; then
  _node_row="  ⚠️  node, npm       for dev server"
elif ! command -v node &>/dev/null; then
  _node_row="  ⚠️  node            for dev server"
else
  _node_row="  ⚠️  npm             for dev server"
fi

echo "┌─────────────────────────────────────────────────┐"
echo "│  Requirements                                   │"
echo "├─────────────────────────────────────────────────┤"
_box_row "$_curl_row"
_box_row "$_node_row"
echo "└─────────────────────────────────────────────────┘"
echo ""

if [[ "$_ok" == false ]]; then
  exit 1
fi

unset -f _box_row
unset _ok _curl_row _node_row

# ----------------------------
# CONFIG
# ----------------------------

FRANKEN_VERSION="${FRANKEN_VERSION:-latest}"   # override: FRANKEN_VERSION=1.11.2 ./lake.setup

# If LAKE_PORT is not set via env, prompt the user (default: 8090)
if [[ -z "${LAKE_PORT:-}" ]]; then
  LAKE_PORT=$(_ask "Dev server port [8090]:" "8090")
fi
COMPOSER_URL="https://getcomposer.org/composer.phar"

# All tools live in .lake/ so Composer won't count them as "existing files"
if [[ -n "${BASH_SOURCE[0]:-}" && -f "${BASH_SOURCE[0]}" ]]; then
  SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
else
  SCRIPT_DIR="$(pwd)"   # piped mode (curl ... | bash): use current directory
fi
TOOLS_DIR="$SCRIPT_DIR/.lake"
FRANKEN_BIN="$TOOLS_DIR/frankenphp"
COMPOSER_BIN="$TOOLS_DIR/composer.phar"

mkdir -p "$TOOLS_DIR"

# ----------------------------
# DETECT OS + ARCH
# ----------------------------

_OS="$(uname -s)"
_ARCH="$(uname -m)"

case "$_OS" in
  Linux*)  FRANKEN_OS="linux" ;;
  Darwin*) FRANKEN_OS="mac"   ;;
  *)       _say "Unsupported OS: $_OS"; exit 1 ;;
esac

# Linux filenames use "x86_64"/"aarch64"; Mac uses "x86_64"/"arm64" — pass uname -m through directly
FRANKEN_ARCH="$_ARCH"
FRANKEN_FILENAME="frankenphp-${FRANKEN_OS}-${FRANKEN_ARCH}"

_say "OS: $FRANKEN_OS  ARCH: $FRANKEN_ARCH  Binary: $FRANKEN_FILENAME"

# ----------------------------
# BUILD DOWNLOAD URL
# ----------------------------

# Binaries are plain executables (no tar.gz).
# Latest:  https://github.com/php/frankenphp/releases/latest/download/<file>
# Pinned:  https://github.com/php/frankenphp/releases/download/v<ver>/<file>

if [[ "$FRANKEN_VERSION" == "latest" ]]; then
  FRANKEN_URL="https://github.com/php/frankenphp/releases/latest/download/${FRANKEN_FILENAME}"
else
  FRANKEN_URL="https://github.com/php/frankenphp/releases/download/v${FRANKEN_VERSION}/${FRANKEN_FILENAME}"
fi

# ----------------------------
# DOWNLOAD FrankenPHP
# ----------------------------

if [[ -f "$FRANKEN_BIN" ]]; then
  _say "FrankenPHP already in .lake/, skipping download."
else
  _say "Downloading FrankenPHP from: $FRANKEN_URL"
  curl -L --progress-bar "$FRANKEN_URL" -o "$FRANKEN_BIN"
  chmod +x "$FRANKEN_BIN"
  _say "FrankenPHP ready."
fi

# .lake/php — strips Composer's -d flags then delegates to frankenphp php-cli
# Also auto-patches PHP_BINARY references in vendor/ on first call per project.
# This is critical for `laravel new` with Boost: the installer calls `.lake/php
# artisan boost:install`, and the shim patches vendor files BEFORE the PHP
# process starts — so Boost's code sees the fixed references.
cat > "$TOOLS_DIR/php" <<'SHIMEOF'
#!/usr/bin/env bash
DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# FrankenPHP php-cli leaves the PHP_BINARY constant empty.
# Export it as an env var so Symfony's PhpExecutableFinder picks up this shim.
export PHP_BINARY="$DIR/php"
export PATH="$DIR:$PATH"
_confirm() {
  local _ans
  printf '\e[1;31m❓ %s [Y/n]:\e[0m ' "$*" >&2
  read -r _ans </dev/tty
  _ans="${_ans:-Y}"
  [[ "$_ans" =~ ^[Yy]$ ]]
}
# Auto-patch PHP_BINARY references in vendor/ when packages change.
# Compare marker timestamp against installed.json so new packages get patched.
if [[ -d "vendor" ]] && [[ -f "$DIR/fix-php-binary" ]]; then
  _need_patch=0
  if [[ ! -f "vendor/.lake-patched" ]]; then
    _need_patch=1
  elif [[ -f "vendor/composer/installed.json" ]] && [[ "vendor/composer/installed.json" -nt "vendor/.lake-patched" ]]; then
    _need_patch=1
  fi
  if [[ $_need_patch -eq 1 ]]; then
    _patch_pkgs=$("$DIR/frankenphp" php-cli "$DIR/fix-php-binary" --list "$(pwd)/vendor" 2>/dev/null)
    if [[ -n "$_patch_pkgs" ]]; then
      printf '\e[31m⚠  PHP_BINARY Patch Warning\e[0m\n' >&2
      printf '\e[31m   New vendor packages need patching for FrankenPHP compatibility:\e[0m\n' >&2
      while IFS= read -r _pkg; do
        printf '   \e[33m• %s\e[0m\n' "$_pkg" >&2
      done <<< "$_patch_pkgs"
      if _confirm "Apply patches to vendor files?"; then
        "$DIR/frankenphp" php-cli "$DIR/fix-php-binary" "$(pwd)/vendor" 2>/dev/null
        touch "$(pwd)/vendor/.lake-patched"
      fi
    else
      # No new patches needed; just update marker
      touch "$(pwd)/vendor/.lake-patched"
    fi
  fi
fi
# Composer passes "-d allow_url_fopen=1 -d disable_functions=" before the script.
# FrankenPHP php-cli doesn't handle -d flags — strip them.
args=()
skip=0
for arg in "$@"; do
  if [[ $skip -eq 1 ]]; then skip=0; continue; fi
  if [[ "$arg" == "-d" ]]; then skip=1; continue; fi
  args+=("$arg")
done
exec "$DIR/frankenphp" php-cli "${args[@]}"
SHIMEOF
chmod +x "$TOOLS_DIR/php"

# .lake/composer — runs composer.phar with PHP_BINARY set so @php hooks work
if [[ ! -f "$TOOLS_DIR/composer" ]]; then
  cat > "$TOOLS_DIR/composer" <<'SHIMEOF'
#!/usr/bin/env bash
DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
export PHP_BINARY="$DIR/php"
export PATH="$DIR:$PATH"
exec "$DIR/frankenphp" php-cli "$DIR/composer.phar" "$@"
SHIMEOF
  chmod +x "$TOOLS_DIR/composer"
fi

# .lake/fix-php-binary — Composer post-autoload-dump hook.
# FrankenPHP php-cli leaves the PHP_BINARY constant empty. Packages that pass
# PHP_BINARY directly to Symfony Process (e.g. laravel/boost) will fail with
# "First element must contain a non-empty program name". This script patches
# those call-sites to fall back to the PHP_BINARY env var (exported by .lake/php).
cat > "$TOOLS_DIR/fix-php-binary" <<'FIXEOF'
#!/usr/bin/env php
<?php
$listOnly = in_array('--list', $argv);
$filteredArgv = array_values(array_filter($argv, fn($a) => $a !== '--list'));

// Accept vendor path as argument (used by .lake/php shim), fall back to CWD then script parent.
$vendor = $filteredArgv[1] ?? (is_dir(getcwd() . '/vendor') ? getcwd() . '/vendor' : dirname(__DIR__) . '/vendor');
if (!is_dir($vendor)) exit(0);

$marker = '/*lake:phpbin*/';
$fallback = "({$marker}(getenv('PHP_BINARY') ?: (PHP_BINARY ?: 'php')))";

$rii = new RecursiveIteratorIterator(
    new RecursiveDirectoryIterator($vendor, RecursiveDirectoryIterator::SKIP_DOTS)
);

$count = 0;
$packages = [];
foreach ($rii as $file) {
    if ($file->getExtension() !== 'php') continue;
    $content = file_get_contents($path = $file->getPathname());
    if (strpos($content, 'PHP_BINARY') === false) continue;
    if (strpos($content, $marker) !== false) continue;

    $patched = $content;
    // Array context: [PHP_BINARY, ...] or [PHP_BINARY]
    $patched = str_replace('[PHP_BINARY,',  "[$fallback,",  $patched);
    $patched = str_replace('[PHP_BINARY]',  "[$fallback]",  $patched);
    // Return statements
    $patched = str_replace('return PHP_BINARY;', "return $fallback;", $patched);
    // Standalone array element on its own line (e.g. ToolExecutor)
    $patched = preg_replace('/^(\s+)PHP_BINARY,$/m', "$1$fallback,", $patched);
    // Function argument: escapeshellarg(PHP_BINARY)
    $patched = str_replace('(PHP_BINARY)',  "($fallback)",  $patched);

    if ($patched !== $content) {
        if ($listOnly) {
            // Extract package name: vendor/org/pkg/... -> org/pkg
            $rel = ltrim(str_replace(realpath($vendor), '', realpath($path)), DIRECTORY_SEPARATOR);
            $parts = explode(DIRECTORY_SEPARATOR, $rel);
            if (count($parts) >= 2) {
                $pkg = $parts[0] . '/' . $parts[1];
                $packages[$pkg] = true;
            }
        } else {
            file_put_contents($path, $patched);
            $count++;
        }
    }
}

if ($listOnly) {
    foreach (array_keys($packages) as $pkg) {
        echo $pkg . PHP_EOL;
    }
    exit(0);
}

if ($count > 0) {
    echo "  Lake: patched PHP_BINARY in $count vendor file(s) for FrankenPHP compatibility." . PHP_EOL;
}

FIXEOF
chmod +x "$TOOLS_DIR/fix-php-binary"

# Prepend .lake to PATH so every @php call in Composer hooks uses the shim.
# Also set PHP_BINARY so Composer doesn't fall back to adding composer.phar to
# its @php argument list (which would re-invoke Composer instead of artisan).
export PATH="$TOOLS_DIR:$PATH"
export PHP_BINARY="$TOOLS_DIR/php"

# ----------------------------
# DOWNLOAD Composer PHAR
# ----------------------------

if [[ -f "$COMPOSER_BIN" ]]; then
  _say "composer.phar already in .lake/, skipping download."
else
  _say "Downloading composer.phar..."
  curl -L --progress-bar "$COMPOSER_URL" -o "$COMPOSER_BIN"
  chmod +x "$COMPOSER_BIN"
  _say "Composer ready."
fi

cd "$SCRIPT_DIR"

# ----------------------------
# INSTALL Laravel Installer
# ----------------------------

# laravel/installer provides `laravel new` which offers interactive stack
# selection (Livewire, Inertia, Breeze, etc.) — not available via create-project.
# Install it as a global Composer package isolated inside .lake/.

LARAVEL_BIN="$TOOLS_DIR/vendor/bin/laravel"

if [[ -f "$LARAVEL_BIN" ]]; then
  _say "laravel/installer already in .lake/, skipping."
else
  _say "Installing laravel/installer..."
  COMPOSER_HOME="$TOOLS_DIR" "$FRANKEN_BIN" php-cli "$COMPOSER_BIN" global require laravel/installer --no-interaction
  _say "Laravel installer ready."
fi

# ----------------------------
# INSTALL Laravel INTO CURRENT DIRECTORY
# ----------------------------

# Strategy: `laravel new` into a temp subdir, then move everything here.
# `laravel new` prompts for starter kit, stack (Livewire/Inertia/etc.), testing
# framework, and more — then handles composer install + initial setup itself.

if [[ -f "$SCRIPT_DIR/artisan" ]]; then
  _say "Laravel already installed (artisan found), skipping."
else
  TMP_DIRNAME=".laravel_setup_tmp"
  TMP_DIR="$SCRIPT_DIR/$TMP_DIRNAME"

  # Clean up any leftover temp dir from a previous failed run
  [[ -d "$TMP_DIR" ]] && rm -rf "$TMP_DIR"

  _say "Creating Laravel project..."
  # Use a temp subdir so the installer gets a clean empty directory.
  # cd "$SCRIPT_DIR" has already run above, so the relative name resolves correctly.
  COMPOSER_HOME="$TOOLS_DIR" "$FRANKEN_BIN" php-cli "$LARAVEL_BIN" new "$TMP_DIRNAME" </dev/tty

  if [[ ! -d "$TMP_DIR" ]]; then
    _say "ERROR: laravel new did not produce $TMP_DIR — check installer output above."
    exit 1
  fi

  # Move everything (including hidden files) into the project root
  cp -a "$TMP_DIR/." "$SCRIPT_DIR/"
  rm -rf "$TMP_DIR"

  _say "Laravel files installed."
fi

# ----------------------------
# PATCH COMPOSER DEV SCRIPT
# ----------------------------

# Laravel's default dev script runs `php artisan serve` which uses PHP's
# built-in -S server. FrankenPHP doesn't support -S — it IS the web server.
# Replace it with `frankenphp run` (reads Caddyfile) in the dev script.

if grep -q "php artisan serve" composer.json 2>/dev/null; then
  if [[ "$_OS" == "Darwin" ]]; then
    sed -i '' 's|php artisan serve|.lake/frankenphp run|g' composer.json
  else
    sed -i 's|php artisan serve|.lake/frankenphp run|g' composer.json
  fi
  _say "Patched composer.json: php artisan serve → .lake/frankenphp run"
fi

# Register .lake/fix-php-binary as a Composer post-autoload-dump hook so that
# every `composer install/update/require` automatically patches PHP_BINARY
# references in vendor files for FrankenPHP compatibility.
if [[ -f "composer.json" ]] && ! grep -q "fix-php-binary" composer.json 2>/dev/null; then
  "$FRANKEN_BIN" php-cli -r "
    \$json = json_decode(file_get_contents('composer.json'), true);
    \$hook = '@php .lake/fix-php-binary';
    \$pad = \$json['scripts']['post-autoload-dump'] ?? [];
    if (!in_array(\$hook, \$pad, true)) {
        \$pad[] = \$hook;
        \$json['scripts']['post-autoload-dump'] = \$pad;
        file_put_contents('composer.json', json_encode(\$json, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES) . \"\n\");
    }
  "
  _say "Patched composer.json: added post-autoload-dump hook for PHP_BINARY fix"
fi

# ----------------------------
# INSTALL / ENSURE DEPENDENCIES
# ----------------------------

if [[ ! -d "vendor" ]]; then
  _say "Running composer install..."
  "$FRANKEN_BIN" php-cli "$COMPOSER_BIN" install --no-interaction
fi

# Run the PHP_BINARY fixer with user consent.
if [[ -d "vendor" ]]; then
  _patch_pkgs=$("$FRANKEN_BIN" php-cli "$TOOLS_DIR/fix-php-binary" --list 2>/dev/null)
  if [[ -n "$_patch_pkgs" ]]; then
    echo ""
    printf '\e[31m⚠  PHP_BINARY Patch Warning\e[0m\n'
    printf '\e[31m   FrankenPHP leaves PHP_BINARY empty. Lake will patch these vendor packages\e[0m\n'
    printf '\e[31m   to use the PHP_BINARY environment variable instead:\e[0m\n'
    echo ""
    while IFS= read -r _pkg; do
      printf '   \e[33m• %s\e[0m\n' "$_pkg"
    done <<< "$_patch_pkgs"
    echo ""
    if _confirm "Apply patches to vendor files?"; then
      "$FRANKEN_BIN" php-cli "$TOOLS_DIR/fix-php-binary"
      _say "PHP_BINARY patched in vendor packages."
    else
      _say "Skipped PHP_BINARY patching. Some packages may not work correctly under FrankenPHP."
    fi
  fi
fi

# ----------------------------
# ENVIRONMENT SETUP
# ----------------------------

if [[ ! -f ".env" ]]; then
  cp .env.example .env
  _say ".env created from .env.example"
fi

# Align APP_URL with the FrankenPHP port (Laravel defaults to 8000, we use LAKE_PORT)
if [[ "$_OS" == "Darwin" ]]; then
  sed -i '' "s|^APP_URL=.*|APP_URL=http://localhost:${LAKE_PORT}|" .env
else
  sed -i "s|^APP_URL=.*|APP_URL=http://localhost:${LAKE_PORT}|" .env
fi
_say "APP_URL set to http://localhost:${LAKE_PORT}"

if grep -q "^APP_KEY=base64:" .env 2>/dev/null; then
  _say "Application key already set, skipping."
else
  _say "Generating application key..."
  "$FRANKEN_BIN" php-cli artisan key:generate --ansi
fi

# Replaces post-autoload-dump: package:discover
_say "Discovering packages..."
"$FRANKEN_BIN" php-cli artisan package:discover --ansi

# Replaces post-create-project-cmd: create SQLite database file + migrate
if [[ ! -f "database/database.sqlite" ]]; then
  touch database/database.sqlite
  _say "Created database/database.sqlite"
fi

_say "Running migrations..."
"$FRANKEN_BIN" php-cli artisan migrate --graceful --ansi

# ----------------------------
# STORAGE PERMISSIONS
# ----------------------------

chmod -R 775 storage bootstrap/cache
_say "Storage permissions set."

# ----------------------------
# CREATE DEV Caddyfile
# ----------------------------

if [[ ! -f "Caddyfile" ]]; then
  cat > Caddyfile <<CADDYEOF
{
    frankenphp
    order php_server before file_server
}

http://localhost:${LAKE_PORT} {
    root * public

    # Route everything through index.php (Laravel router)
    php_server
}
CADDYEOF
  _say "Caddyfile created (port ${LAKE_PORT})."
fi

# ----------------------------
# ADD .lake TO .gitignore
# ----------------------------

if [[ -f ".gitignore" ]] && ! grep -qxF ".lake" .gitignore; then
  echo ".lake" >> .gitignore
  _say "Added .lake to .gitignore"
fi

# ----------------------------
# PATCH .mcp.json FOR LAKE
# ----------------------------

# Packages like laravel/boost write .mcp.json with "command": "php".
# In a Lake environment there is no system PHP — rewrite to ".lake/php".
if [[ -f ".mcp.json" ]] && grep -qE '"command"\s*:\s*"php"' .mcp.json 2>/dev/null; then
  echo ""
  _say "Detected .mcp.json with \"command\": \"php\"."
  _say "Lake needs to change this to \".lake/php\" (no system PHP available)."
  if _confirm "Patch .mcp.json?"; then
    "$FRANKEN_BIN" php-cli -r "
      \$path = '.mcp.json';
      \$content = file_get_contents(\$path);
      \$patched = preg_replace('/\"command\"(\s*:\s*)\"php\"/', '\"command\"\$1\".lake/php\"', \$content);
      if (\$patched !== null && \$patched !== \$content) {
        file_put_contents(\$path, \$patched);
      }
    "
    _say "Patched .mcp.json: php → .lake/php"
  else
    _say "Skipped .mcp.json patching."
  fi
fi

# ----------------------------
# DONE
# ----------------------------

echo ""
echo "======================================"
_say "Lake is ready"
echo "======================================"
echo ""
_say "Start dev server (FrankenPHP + queue + logs + Vite):"
_say "  .lake/composer run dev"
echo ""
_say "Then open: http://localhost:${LAKE_PORT}"
echo ""
_say "Artisan commands:"
_say "  .lake/php artisan <command>"
echo ""
_say "Composer commands:"
_say "  .lake/composer require <package>"
echo ""
